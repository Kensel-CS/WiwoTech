import { __assign, __awaiter, __generator, __spreadArray } from "tslib";
import { useCallback, useEffect, useMemo, useRef, useState } from 'react';
import uniqBy from 'lodash.uniqby';
import { MAX_QUERY_CHANNELS_LIMIT } from '../utils';
import { useChatContext } from '../../../context/ChatContext';
var RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS = 5000;
var MIN_RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS = 2000;
export var usePaginatedChannels = function (client, filters, sort, options, activeChannelHandler, recoveryThrottleIntervalMs) {
    if (recoveryThrottleIntervalMs === void 0) { recoveryThrottleIntervalMs = RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS; }
    var _a = useChatContext('usePaginatedChannels').channelsQueryState, error = _a.error, setError = _a.setError, setQueryInProgress = _a.setQueryInProgress;
    var _b = useState([]), channels = _b[0], setChannels = _b[1];
    var _c = useState(true), hasNextPage = _c[0], setHasNextPage = _c[1];
    var lastRecoveryTimestamp = useRef();
    var recoveryThrottleInterval = recoveryThrottleIntervalMs < MIN_RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS
        ? MIN_RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS
        : recoveryThrottleIntervalMs
            ? recoveryThrottleIntervalMs
            : RECOVER_LOADED_CHANNELS_THROTTLE_INTERVAL_IN_MS;
    // memoize props
    var filterString = useMemo(function () { return JSON.stringify(filters); }, [filters]);
    var sortString = useMemo(function () { return JSON.stringify(sort); }, [sort]);
    var queryChannels = function (queryType) { return __awaiter(void 0, void 0, void 0, function () {
        var offset, newOptions, channelQueryResponse, newChannels, err_1;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    setError(null);
                    if (queryType === 'reload') {
                        setChannels([]);
                        setQueryInProgress('reload');
                    }
                    else {
                        setQueryInProgress('load-more');
                    }
                    offset = queryType === 'reload' ? 0 : channels.length;
                    newOptions = __assign({ limit: (_a = options === null || options === void 0 ? void 0 : options.limit) !== null && _a !== void 0 ? _a : MAX_QUERY_CHANNELS_LIMIT, offset: offset }, options);
                    _b.label = 1;
                case 1:
                    _b.trys.push([1, 3, , 4]);
                    return [4 /*yield*/, client.queryChannels(filters, sort || {}, newOptions)];
                case 2:
                    channelQueryResponse = _b.sent();
                    newChannels = queryType === 'reload'
                        ? channelQueryResponse
                        : uniqBy(__spreadArray(__spreadArray([], channels, true), channelQueryResponse, true), 'cid');
                    setChannels(newChannels);
                    setHasNextPage(channelQueryResponse.length >= newOptions.limit);
                    // Set active channel only on load of first page
                    if (!offset && activeChannelHandler) {
                        activeChannelHandler(newChannels, setChannels);
                    }
                    return [3 /*break*/, 4];
                case 3:
                    err_1 = _b.sent();
                    console.warn(err_1);
                    setError(err_1);
                    return [3 /*break*/, 4];
                case 4:
                    setQueryInProgress(null);
                    return [2 /*return*/];
            }
        });
    }); };
    var throttleRecover = useCallback(function () {
        var now = Date.now();
        var isFirstRecovery = !lastRecoveryTimestamp.current;
        var timeElapsedSinceLastRecoveryMs = lastRecoveryTimestamp.current
            ? now - lastRecoveryTimestamp.current
            : 0;
        if (!isFirstRecovery && timeElapsedSinceLastRecoveryMs < recoveryThrottleInterval && !error) {
            return;
        }
        lastRecoveryTimestamp.current = now;
        queryChannels('reload');
    }, [error, queryChannels, recoveryThrottleInterval]);
    var loadNextPage = function () {
        queryChannels();
    };
    useEffect(function () {
        if (client.recoverStateOnReconnect)
            return;
        var unsubscribe = client.on('connection.recovered', throttleRecover).unsubscribe;
        return function () {
            unsubscribe();
        };
    }, [client, throttleRecover]);
    useEffect(function () {
        queryChannels('reload');
    }, [filterString, sortString]);
    return {
        channels: channels,
        hasNextPage: hasNextPage,
        loadNextPage: loadNextPage,
        setChannels: setChannels,
    };
};
