import { __assign, __awaiter, __generator, __rest } from "tslib";
import React, { useCallback, useEffect, useMemo, useRef } from 'react';
import { Virtuoso, } from 'react-virtuoso';
import { GiphyPreviewMessage as DefaultGiphyPreviewMessage } from './GiphyPreviewMessage';
import { useLastReadData } from './hooks';
import { useGiphyPreview, useMessageSetKey, useNewMessageNotification, usePrependedMessagesCount, useScrollToBottomOnNewMessage, useShouldForceScrollToBottom, } from './hooks/VirtualizedMessageList';
import { MessageNotification as DefaultMessageNotification } from './MessageNotification';
import { MessageListNotifications as DefaultMessageListNotifications } from './MessageListNotifications';
import { MessageListMainPanel } from './MessageListMainPanel';
import { getGroupStyles, getLastReceived, processMessages } from './utils';
import { MessageSimple } from '../Message';
import { DateSeparator as DefaultDateSeparator } from '../DateSeparator';
import { EventComponent } from '../EventComponent';
import { calculateFirstItemIndex, calculateItemIndex, EmptyPlaceholder, Footer, Header, Item, messageRenderer, } from './VirtualizedMessageListComponents';
import { useChannelActionContext, } from '../../context/ChannelActionContext';
import { useChannelStateContext, } from '../../context/ChannelStateContext';
import { useChatContext } from '../../context/ChatContext';
import { useComponentContext } from '../../context/ComponentContext';
function captureResizeObserverExceededError(e) {
    if (e.message === 'ResizeObserver loop completed with undelivered notifications.' ||
        e.message === 'ResizeObserver loop limit exceeded') {
        e.stopImmediatePropagation();
    }
}
function useCaptureResizeObserverExceededError() {
    useEffect(function () {
        window.addEventListener('error', captureResizeObserverExceededError);
        return function () {
            window.removeEventListener('error', captureResizeObserverExceededError);
        };
    }, []);
}
function fractionalItemSize(element) {
    return element.getBoundingClientRect().height;
}
function findMessageIndex(messages, id) {
    return messages.findIndex(function (message) { return message.id === id; });
}
function calculateInitialTopMostItemIndex(messages, highlightedMessageId) {
    if (highlightedMessageId) {
        var index = findMessageIndex(messages, highlightedMessageId);
        if (index !== -1) {
            return { align: 'center', index: index };
        }
    }
    return messages.length - 1;
}
var VirtualizedMessageListWithContext = function (props) {
    var additionalMessageInputProps = props.additionalMessageInputProps, _a = props.additionalVirtuosoProps, additionalVirtuosoProps = _a === void 0 ? {} : _a, channel = props.channel, closeReactionSelectorOnClick = props.closeReactionSelectorOnClick, customMessageActions = props.customMessageActions, customMessageRenderer = props.customMessageRenderer, defaultItemHeight = props.defaultItemHeight, _b = props.disableDateSeparator, disableDateSeparator = _b === void 0 ? true : _b, groupStyles = props.groupStyles, hasMore = props.hasMore, hasMoreNewer = props.hasMoreNewer, head = props.head, _c = props.hideDeletedMessages, hideDeletedMessages = _c === void 0 ? false : _c, _d = props.hideNewMessageSeparator, hideNewMessageSeparator = _d === void 0 ? false : _d, highlightedMessageId = props.highlightedMessageId, jumpToLatestMessage = props.jumpToLatestMessage, loadingMore = props.loadingMore, loadMore = props.loadMore, loadMoreNewer = props.loadMoreNewer, MessageUIComponentFromProps = props.Message, messageActions = props.messageActions, _e = props.messageLimit, messageLimit = _e === void 0 ? 100 : _e, messages = props.messages, notifications = props.notifications, 
    // TODO: refactor to scrollSeekPlaceHolderConfiguration and components.ScrollSeekPlaceholder, like the Virtuoso Component
    _f = props.overscan, 
    // TODO: refactor to scrollSeekPlaceHolderConfiguration and components.ScrollSeekPlaceholder, like the Virtuoso Component
    overscan = _f === void 0 ? 0 : _f, read = props.read, _g = props.returnAllReadData, returnAllReadData = _g === void 0 ? false : _g, scrollSeekPlaceHolder = props.scrollSeekPlaceHolder, _h = props.scrollToLatestMessageOnFocus, scrollToLatestMessageOnFocus = _h === void 0 ? false : _h, _j = props.separateGiphyPreview, separateGiphyPreview = _j === void 0 ? false : _j, _k = props.shouldGroupByUser, shouldGroupByUser = _k === void 0 ? false : _k, _l = props.stickToBottomScrollBehavior, stickToBottomScrollBehavior = _l === void 0 ? 'smooth' : _l, suppressAutoscroll = props.suppressAutoscroll, threadList = props.threadList;
    var virtuosoComponentsFromProps = additionalVirtuosoProps.components, overridingVirtuosoProps = __rest(additionalVirtuosoProps, ["components"]);
    // Stops errors generated from react-virtuoso to bubble up
    // to Sentry or other tracking tools.
    useCaptureResizeObserverExceededError();
    var _m = useComponentContext('VirtualizedMessageList'), _o = _m.DateSeparator, DateSeparator = _o === void 0 ? DefaultDateSeparator : _o, _p = _m.GiphyPreviewMessage, GiphyPreviewMessage = _p === void 0 ? DefaultGiphyPreviewMessage : _p, _q = _m.MessageListNotifications, MessageListNotifications = _q === void 0 ? DefaultMessageListNotifications : _q, _r = _m.MessageNotification, MessageNotification = _r === void 0 ? DefaultMessageNotification : _r, _s = _m.MessageSystem, MessageSystem = _s === void 0 ? EventComponent : _s, _t = _m.VirtualMessage, MessageUIComponentFromContext = _t === void 0 ? MessageSimple : _t;
    var MessageUIComponent = MessageUIComponentFromProps || MessageUIComponentFromContext;
    var _u = useChatContext('VirtualizedMessageList'), client = _u.client, customClasses = _u.customClasses;
    var virtuoso = useRef(null);
    var lastRead = useMemo(function () { var _a; return (_a = channel.lastRead) === null || _a === void 0 ? void 0 : _a.call(channel); }, [channel]);
    var _v = useGiphyPreview(separateGiphyPreview), giphyPreviewMessage = _v.giphyPreviewMessage, setGiphyPreviewMessage = _v.setGiphyPreviewMessage;
    var processedMessages = useMemo(function () {
        if (typeof messages === 'undefined') {
            return [];
        }
        if (disableDateSeparator &&
            !hideDeletedMessages &&
            hideNewMessageSeparator &&
            !separateGiphyPreview) {
            return messages;
        }
        return processMessages({
            enableDateSeparator: !disableDateSeparator,
            hideDeletedMessages: hideDeletedMessages,
            hideNewMessageSeparator: hideNewMessageSeparator,
            lastRead: lastRead,
            messages: messages,
            setGiphyPreviewMessage: setGiphyPreviewMessage,
            userId: client.userID || '',
        });
    }, [
        disableDateSeparator,
        hideDeletedMessages,
        hideNewMessageSeparator,
        lastRead,
        messages,
        messages === null || messages === void 0 ? void 0 : messages.length,
        client.userID,
    ]);
    // get the mapping of own messages to array of users who read them
    var ownMessagesReadByOthers = useLastReadData({
        messages: processedMessages,
        read: read,
        returnAllReadData: returnAllReadData,
        userID: client.userID,
    });
    var lastReceivedMessageId = useMemo(function () { return getLastReceived(processedMessages); }, [
        processedMessages,
    ]);
    var groupStylesFn = groupStyles || getGroupStyles;
    var messageGroupStyles = useMemo(function () {
        return processedMessages.reduce(function (acc, message, i) {
            var style = groupStylesFn(message, processedMessages[i - 1], processedMessages[i + 1], !shouldGroupByUser);
            if (style)
                acc[message.id] = style;
            return acc;
        }, {});
    }, 
    // processedMessages were incorrectly rebuilt with a new object identity at some point, hence the .length usage
    [processedMessages.length, shouldGroupByUser, groupStylesFn]);
    var _w = useNewMessageNotification(processedMessages, client.userID, hasMoreNewer), atBottom = _w.atBottom, isMessageListScrolledToBottom = _w.isMessageListScrolledToBottom, newMessagesNotification = _w.newMessagesNotification, setIsMessageListScrolledToBottom = _w.setIsMessageListScrolledToBottom, setNewMessagesNotification = _w.setNewMessagesNotification;
    var scrollToBottom = useCallback(function () { return __awaiter(void 0, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    if (!hasMoreNewer) return [3 /*break*/, 2];
                    return [4 /*yield*/, jumpToLatestMessage()];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
                case 2:
                    if (virtuoso.current) {
                        virtuoso.current.scrollToIndex(processedMessages.length - 1);
                    }
                    setNewMessagesNotification(false);
                    return [2 /*return*/];
            }
        });
    }); }, [
        virtuoso,
        processedMessages,
        setNewMessagesNotification,
        // processedMessages were incorrectly rebuilt with a new object identity at some point, hence the .length usage
        processedMessages.length,
        hasMoreNewer,
        jumpToLatestMessage,
    ]);
    useScrollToBottomOnNewMessage({ messages: messages, scrollToBottom: scrollToBottom, scrollToLatestMessageOnFocus: scrollToLatestMessageOnFocus });
    var numItemsPrepended = usePrependedMessagesCount(processedMessages, !disableDateSeparator);
    var messageSetKey = useMessageSetKey({ messages: messages }).messageSetKey;
    var shouldForceScrollToBottom = useShouldForceScrollToBottom(processedMessages, client.userID);
    var followOutput = function (isAtBottom) {
        if (hasMoreNewer || suppressAutoscroll) {
            return false;
        }
        if (shouldForceScrollToBottom()) {
            return isAtBottom ? stickToBottomScrollBehavior : 'auto';
        }
        // a message from another user has been received - don't scroll to bottom unless already there
        return isAtBottom ? stickToBottomScrollBehavior : false;
    };
    var computeItemKey = useCallback(function (index, _, _a) {
        var numItemsPrepended = _a.numItemsPrepended, processedMessages = _a.processedMessages;
        return processedMessages[calculateItemIndex(index, numItemsPrepended)].id;
    }, []);
    var atBottomStateChange = function (isAtBottom) {
        atBottom.current = isAtBottom;
        setIsMessageListScrolledToBottom(isAtBottom);
        if (isAtBottom && newMessagesNotification) {
            setNewMessagesNotification(false);
        }
    };
    var startReached = function () {
        if (hasMore && loadMore) {
            loadMore(messageLimit);
        }
    };
    var endReached = function () {
        if (hasMoreNewer && loadMoreNewer) {
            loadMoreNewer(messageLimit);
        }
    };
    useEffect(function () {
        var _a;
        if (highlightedMessageId) {
            var index = findMessageIndex(processedMessages, highlightedMessageId);
            if (index !== -1) {
                (_a = virtuoso.current) === null || _a === void 0 ? void 0 : _a.scrollToIndex({ align: 'center', index: index });
            }
        }
    }, [highlightedMessageId]);
    if (!processedMessages)
        return null;
    return (React.createElement(React.Fragment, null,
        React.createElement(MessageListMainPanel, null,
            React.createElement("div", { className: (customClasses === null || customClasses === void 0 ? void 0 : customClasses.virtualizedMessageList) || 'str-chat__virtual-list' },
                React.createElement(Virtuoso, __assign({ atBottomStateChange: atBottomStateChange, atBottomThreshold: 200, className: 'str-chat__message-list-scroll', components: __assign({ EmptyPlaceholder: EmptyPlaceholder, Footer: Footer, Header: Header, Item: Item }, virtuosoComponentsFromProps), computeItemKey: computeItemKey, context: {
                        additionalMessageInputProps: additionalMessageInputProps,
                        closeReactionSelectorOnClick: closeReactionSelectorOnClick,
                        customClasses: customClasses,
                        customMessageActions: customMessageActions,
                        customMessageRenderer: customMessageRenderer,
                        DateSeparator: DateSeparator,
                        head: head,
                        lastReceivedMessageId: lastReceivedMessageId,
                        loadingMore: loadingMore,
                        Message: MessageUIComponent,
                        messageActions: messageActions,
                        messageGroupStyles: messageGroupStyles,
                        MessageSystem: MessageSystem,
                        numItemsPrepended: numItemsPrepended,
                        ownMessagesReadByOthers: ownMessagesReadByOthers,
                        processedMessages: processedMessages,
                        shouldGroupByUser: shouldGroupByUser,
                        threadList: threadList,
                        virtuosoRef: virtuoso,
                    }, endReached: endReached, firstItemIndex: calculateFirstItemIndex(numItemsPrepended), followOutput: followOutput, increaseViewportBy: { bottom: 200, top: 0 }, initialTopMostItemIndex: calculateInitialTopMostItemIndex(processedMessages, highlightedMessageId), itemContent: messageRenderer, itemSize: fractionalItemSize, key: messageSetKey, overscan: overscan, ref: virtuoso, startReached: startReached, style: { overflowX: 'hidden' }, totalCount: processedMessages.length }, overridingVirtuosoProps, (scrollSeekPlaceHolder ? { scrollSeek: scrollSeekPlaceHolder } : {}), (defaultItemHeight ? { defaultItemHeight: defaultItemHeight } : {}))))),
        React.createElement(MessageListNotifications, { hasNewMessages: newMessagesNotification, isMessageListScrolledToBottom: isMessageListScrolledToBottom, isNotAtLatestMessageSet: hasMoreNewer, MessageNotification: MessageNotification, notifications: notifications, scrollToBottom: scrollToBottom, threadList: threadList }),
        giphyPreviewMessage && React.createElement(GiphyPreviewMessage, { message: giphyPreviewMessage })));
};
/**
 * The VirtualizedMessageList component renders a list of messages in a virtualized list.
 * It is a consumer of the React contexts set in [Channel](https://github.com/GetStream/stream-chat-react/blob/master/src/components/Channel/Channel.tsx).
 */
export function VirtualizedMessageList(props) {
    var _a = useChannelActionContext('VirtualizedMessageList'), jumpToLatestMessage = _a.jumpToLatestMessage, loadMore = _a.loadMore, loadMoreNewer = _a.loadMoreNewer;
    var _b = useChannelStateContext('VirtualizedMessageList'), channel = _b.channel, hasMore = _b.hasMore, hasMoreNewer = _b.hasMoreNewer, highlightedMessageId = _b.highlightedMessageId, loadingMore = _b.loadingMore, loadingMoreNewer = _b.loadingMoreNewer, contextMessages = _b.messages, notifications = _b.notifications, read = _b.read, suppressAutoscroll = _b.suppressAutoscroll;
    var messages = props.messages || contextMessages;
    return (React.createElement(VirtualizedMessageListWithContext, __assign({ channel: channel, hasMore: !!hasMore, hasMoreNewer: !!hasMoreNewer, highlightedMessageId: highlightedMessageId, jumpToLatestMessage: jumpToLatestMessage, loadingMore: !!loadingMore, loadingMoreNewer: !!loadingMoreNewer, loadMore: loadMore, loadMoreNewer: loadMoreNewer, messages: messages, notifications: notifications, read: read, suppressAutoscroll: suppressAutoscroll }, props)));
}
